{
  "version": 3,
  "sources": ["../../jsonc-parser/lib/esm/impl/scanner.js", "../../jsonc-parser/lib/esm/impl/format.js", "../../jsonc-parser/lib/esm/impl/parser.js", "../../jsonc-parser/lib/esm/impl/edit.js", "../../jsonc-parser/lib/esm/main.js"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text, ignoreTrivia = false) {\n    const len = text.length;\n    let pos = 0, value = '', tokenOffset = 0, token = 16 /* SyntaxKind.Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* ScanError.None */;\n    function scanHexDigits(count, exact) {\n        let digits = 0;\n        let value = 0;\n        while (digits < count || !exact) {\n            let ch = text.charCodeAt(pos);\n            if (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) {\n                value = value * 16 + ch - 48 /* CharacterCodes._0 */;\n            }\n            else if (ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */) {\n                value = value * 16 + ch - 65 /* CharacterCodes.A */ + 10;\n            }\n            else if (ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */) {\n                value = value * 16 + ch - 97 /* CharacterCodes.a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* SyntaxKind.Unknown */;\n        scanError = 0 /* ScanError.None */;\n    }\n    function scanNumber() {\n        let start = pos;\n        if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        let end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */ || text.charCodeAt(pos) === 101 /* CharacterCodes.e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */ || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        let result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                break;\n            }\n            const ch = text.charCodeAt(pos);\n            if (ch === 34 /* CharacterCodes.doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* CharacterCodes.backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                    break;\n                }\n                const ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* CharacterCodes.doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* CharacterCodes.backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* CharacterCodes.slash */:\n                        result += '/';\n                        break;\n                    case 98 /* CharacterCodes.b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* CharacterCodes.f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* CharacterCodes.n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* CharacterCodes.r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* CharacterCodes.t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* CharacterCodes.u */:\n                        const ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* ScanError.InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* ScanError.InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* ScanError.InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* ScanError.None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* SyntaxKind.EOF */;\n        }\n        let code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* SyntaxKind.Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* SyntaxKind.LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* CharacterCodes.openBrace */:\n                pos++;\n                return token = 1 /* SyntaxKind.OpenBraceToken */;\n            case 125 /* CharacterCodes.closeBrace */:\n                pos++;\n                return token = 2 /* SyntaxKind.CloseBraceToken */;\n            case 91 /* CharacterCodes.openBracket */:\n                pos++;\n                return token = 3 /* SyntaxKind.OpenBracketToken */;\n            case 93 /* CharacterCodes.closeBracket */:\n                pos++;\n                return token = 4 /* SyntaxKind.CloseBracketToken */;\n            case 58 /* CharacterCodes.colon */:\n                pos++;\n                return token = 6 /* SyntaxKind.ColonToken */;\n            case 44 /* CharacterCodes.comma */:\n                pos++;\n                return token = 5 /* SyntaxKind.CommaToken */;\n            // strings\n            case 34 /* CharacterCodes.doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* SyntaxKind.StringLiteral */;\n            // comments\n            case 47 /* CharacterCodes.slash */:\n                const start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* SyntaxKind.LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {\n                    pos += 2;\n                    const safeLength = len - 1; // For lookahead.\n                    let commentClosed = false;\n                    while (pos < safeLength) {\n                        const ch = text.charCodeAt(pos);\n                        if (ch === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* ScanError.UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* SyntaxKind.BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* SyntaxKind.Unknown */;\n            // numbers\n            case 45 /* CharacterCodes.minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* SyntaxKind.Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* CharacterCodes._0 */:\n            case 49 /* CharacterCodes._1 */:\n            case 50 /* CharacterCodes._2 */:\n            case 51 /* CharacterCodes._3 */:\n            case 52 /* CharacterCodes._4 */:\n            case 53 /* CharacterCodes._5 */:\n            case 54 /* CharacterCodes._6 */:\n            case 55 /* CharacterCodes._7 */:\n            case 56 /* CharacterCodes._8 */:\n            case 57 /* CharacterCodes._9 */:\n                value += scanNumber();\n                return token = 11 /* SyntaxKind.NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* SyntaxKind.TrueKeyword */;\n                        case 'false': return token = 9 /* SyntaxKind.FalseKeyword */;\n                        case 'null': return token = 7 /* SyntaxKind.NullKeyword */;\n                    }\n                    return token = 16 /* SyntaxKind.Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* SyntaxKind.Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* CharacterCodes.closeBrace */:\n            case 93 /* CharacterCodes.closeBracket */:\n            case 123 /* CharacterCodes.openBrace */:\n            case 91 /* CharacterCodes.openBracket */:\n            case 34 /* CharacterCodes.doubleQuote */:\n            case 58 /* CharacterCodes.colon */:\n            case 44 /* CharacterCodes.comma */:\n            case 47 /* CharacterCodes.slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        let result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* SyntaxKind.LineCommentTrivia */ && result <= 15 /* SyntaxKind.Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: () => pos,\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: () => token,\n        getTokenValue: () => value,\n        getTokenOffset: () => tokenOffset,\n        getTokenLength: () => pos - tokenOffset,\n        getTokenStartLine: () => lineStartOffset,\n        getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,\n        getTokenError: () => scanError,\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* CharacterCodes.space */ || ch === 9 /* CharacterCodes.tab */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* CharacterCodes.lineFeed */ || ch === 13 /* CharacterCodes.carriageReturn */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;\n}\nvar CharacterCodes;\n(function (CharacterCodes) {\n    CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\n    CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\n    CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\n    CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\n    CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\n    CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\n    CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\n    CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\n    CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\n    CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\n    CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\n    CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\n    CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\n    CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\n    CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\n    CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\n    CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\n    CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\n    CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\n    CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\n    CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\n    CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\n    CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\n    CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\n    CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\n    CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\n    CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\n    CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\n    CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\n    CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\n    CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\n    CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\n    CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\n    CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\n    CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\n    CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\n    CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\n    CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\n    CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\n    CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\n    CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\n    CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\n    CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\n    CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\n    CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\n    CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\n    CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\n    CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\n    CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\n    CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\n    CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\n    CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\n    CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\n    CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\n    CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\n    CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\n    CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\n    CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\n    CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\n    CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\n    CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\n    CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\n    CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\n    CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\n    CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\n    CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\n    CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\n    CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\n    CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\n    CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\n    CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\n    CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\n    CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\n    CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\n    CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\n    CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\n    CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\n    CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\n    CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\n    CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\n})(CharacterCodes || (CharacterCodes = {}));\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nexport function format(documentText, range, options) {\n    let initialIndentLevel;\n    let formatText;\n    let formatTextStart;\n    let rangeStart;\n    let rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        let endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    const eol = getEOL(options, documentText);\n    let numberLineBreaks = 0;\n    let indentLevel = 0;\n    let indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    let scanner = createScanner(formatText, false);\n    let hasError = false;\n    function newLinesAndIndent() {\n        if (numberLineBreaks > 1) {\n            return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n        else {\n            return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n    }\n    function scanNext() {\n        let token = scanner.scan();\n        numberLineBreaks = 0;\n        while (token === 15 /* SyntaxKind.Trivia */ || token === 14 /* SyntaxKind.LineBreakTrivia */) {\n            if (token === 14 /* SyntaxKind.LineBreakTrivia */ && options.keepLines) {\n                numberLineBreaks += 1;\n            }\n            else if (token === 14 /* SyntaxKind.LineBreakTrivia */) {\n                numberLineBreaks = 1;\n            }\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* SyntaxKind.Unknown */ || scanner.getTokenError() !== 0 /* ScanError.None */;\n        return token;\n    }\n    const editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && (!range || (startOffset < rangeEnd && endOffset > rangeStart)) && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    let firstToken = scanNext();\n    if (options.keepLines && numberLineBreaks > 0) {\n        addEdit(repeat(eol, numberLineBreaks), 0, 0);\n    }\n    if (firstToken !== 17 /* SyntaxKind.EOF */) {\n        let firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        let initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* SyntaxKind.EOF */) {\n        let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        let secondToken = scanNext();\n        let replaceContent = '';\n        let needsLineBreak = false;\n        while (numberLineBreaks === 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */)) {\n            let commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            needsLineBreak = secondToken === 12 /* SyntaxKind.LineCommentTrivia */;\n            replaceContent = needsLineBreak ? newLinesAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* SyntaxKind.CloseBraceToken */) {\n            if (firstToken !== 1 /* SyntaxKind.OpenBraceToken */) {\n                indentLevel--;\n            }\n            ;\n            if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1 /* SyntaxKind.OpenBraceToken */) {\n                replaceContent = newLinesAndIndent();\n            }\n            else if (options.keepLines) {\n                replaceContent = ' ';\n            }\n        }\n        else if (secondToken === 4 /* SyntaxKind.CloseBracketToken */) {\n            if (firstToken !== 3 /* SyntaxKind.OpenBracketToken */) {\n                indentLevel--;\n            }\n            ;\n            if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3 /* SyntaxKind.OpenBracketToken */) {\n                replaceContent = newLinesAndIndent();\n            }\n            else if (options.keepLines) {\n                replaceContent = ' ';\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* SyntaxKind.OpenBracketToken */:\n                case 1 /* SyntaxKind.OpenBraceToken */:\n                    indentLevel++;\n                    if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 5 /* SyntaxKind.CommaToken */:\n                    if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                    replaceContent = newLinesAndIndent();\n                    break;\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (!needsLineBreak) {\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* SyntaxKind.ColonToken */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (!needsLineBreak) {\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 10 /* SyntaxKind.StringLiteral */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (secondToken === 6 /* SyntaxKind.ColonToken */ && !needsLineBreak) {\n                        replaceContent = '';\n                    }\n                    break;\n                case 7 /* SyntaxKind.NullKeyword */:\n                case 8 /* SyntaxKind.TrueKeyword */:\n                case 9 /* SyntaxKind.FalseKeyword */:\n                case 11 /* SyntaxKind.NumericLiteral */:\n                case 2 /* SyntaxKind.CloseBraceToken */:\n                case 4 /* SyntaxKind.CloseBracketToken */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        if ((secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */) && !needsLineBreak) {\n                            replaceContent = ' ';\n                        }\n                        else if (secondToken !== 5 /* SyntaxKind.CommaToken */ && secondToken !== 17 /* SyntaxKind.EOF */) {\n                            hasError = true;\n                        }\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (numberLineBreaks > 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */)) {\n                replaceContent = newLinesAndIndent();\n            }\n        }\n        if (secondToken === 17 /* SyntaxKind.EOF */) {\n            if (options.keepLines && numberLineBreaks > 0) {\n                replaceContent = newLinesAndIndent();\n            }\n            else {\n                replaceContent = options.insertFinalNewline ? eol : '';\n            }\n        }\n        const secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    let result = '';\n    for (let i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    let i = 0;\n    let nChars = 0;\n    const tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        let ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    const segments = []; // strings or numbers\n    const earlyReturnException = new Object();\n    let previousNode = undefined;\n    const previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    let isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: (name, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: (value, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: (sep, offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    const last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode,\n        isAtPropertyKey,\n        matches: (pattern) => {\n            let k = 0;\n            for (let i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentProperty = null;\n    let currentParent = [];\n    const previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    const visitor = {\n        onObjectBegin: () => {\n            const object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: (name) => {\n            currentProperty = name;\n        },\n        onObjectEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: () => {\n            const array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    const visitor = {\n        onObjectBegin: (offset) => {\n            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: (name, offset, length) => {\n            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });\n        },\n        onObjectEnd: (offset, length) => {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: (offset, length) => {\n            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: (offset, length) => {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: (value, offset, length) => {\n            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: (sep, offset, length) => {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    const result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    let node = root;\n    for (let segment of path) {\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            let found = false;\n            for (const propertyNode of node.children) {\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            const index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    const path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        const key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        const index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            const obj = Object.create(null);\n            for (let prop of node.children) {\n                const valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound = false) {\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound = false) {\n    if (contains(node, offset, includeRightBound)) {\n        const children = node.children;\n        if (Array.isArray(children)) {\n            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                const item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options = ParseOptions.DEFAULT) {\n    const _scanner = createScanner(text, false);\n    // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n    // to not affect visitor functions which stored a reference to a previous JSONPath\n    const _jsonPath = [];\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toNoArgVisitWithPath(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toOneArgVisitWithPath(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    const disallowComments = options && options.disallowComments;\n    const allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            const token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* ScanError.InvalidUnicode */:\n                    handleError(14 /* ParseErrorCode.InvalidUnicode */);\n                    break;\n                case 5 /* ScanError.InvalidEscapeCharacter */:\n                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);\n                    break;\n                case 3 /* ScanError.UnexpectedEndOfNumber */:\n                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* ScanError.UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* ScanError.UnexpectedEndOfString */:\n                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);\n                    break;\n                case 6 /* ScanError.InvalidCharacter */:\n                    handleError(16 /* ParseErrorCode.InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    handleError(1 /* ParseErrorCode.InvalidSymbol */);\n                    break;\n                case 15 /* SyntaxKind.Trivia */:\n                case 14 /* SyntaxKind.LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter = [], skipUntil = []) {\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            let token = _scanner.getToken();\n            while (token !== 17 /* SyntaxKind.EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        const value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n            // add property name afterwards\n            _jsonPath.push(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* SyntaxKind.NumericLiteral */:\n                const tokenValue = _scanner.getTokenValue();\n                let value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* SyntaxKind.NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* SyntaxKind.TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* SyntaxKind.FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {\n            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n        }\n        _jsonPath.pop(); // remove processed property name\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        let needsComma = false;\n        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {\n            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        let isFirstElement = true;\n        let needsComma = false;\n        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (isFirstElement) {\n                _jsonPath.push(0);\n                isFirstElement = false;\n            }\n            else {\n                _jsonPath[_jsonPath.length - 1]++;\n            }\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (!isFirstElement) {\n            _jsonPath.pop(); // remove array index\n        }\n        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {\n            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* SyntaxKind.OpenBracketToken */:\n                return parseArray();\n            case 1 /* SyntaxKind.OpenBraceToken */:\n                return parseObject();\n            case 10 /* SyntaxKind.StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* SyntaxKind.LineCommentTrivia */:\n            case 13 /* SyntaxKind.BlockCommentTrivia */:\n            case 17 /* SyntaxKind.EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* SyntaxKind.EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n    const path = originalPath.slice();\n    const errors = [];\n    const root = parseTree(text, errors);\n    let parent = void 0;\n    let lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = { [lastSegment]: value };\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        const existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                const propertyIndex = parent.children.indexOf(existing.parent);\n                let removeBegin;\n                let removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    let previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        let next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n            const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(p => p.children[0].value)) : parent.children.length;\n            let edit;\n            if (index > 0) {\n                let previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        const insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            const newProperty = `${JSON.stringify(value)}`;\n            let edit;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                const previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            const removalIndex = lastSegment;\n            const toRemove = parent.children[removalIndex];\n            let edit;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                let previous = parent.children[removalIndex - 1];\n                let offset = previous.offset + previous.length;\n                let parentEndOffset = parent.offset + parent.length;\n                edit = { offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            let edit;\n            const newProperty = `${JSON.stringify(value)}`;\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                const toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                const previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(`Can not ${value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')} Array index ${insertIndex} as length is not sufficient`);\n        }\n    }\n    else {\n        throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    let newText = applyEdit(text, edit);\n    // format the new text\n    let begin = edit.offset;\n    let end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    const edits = format(newText, { offset: begin, length: end - begin }, { ...options.formattingOptions, keepLines: false });\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (let i = edits.length - 1; i >= 0; i--) {\n        const edit = edits[i];\n        newText = applyEdit(newText, edit);\n        begin = Math.min(begin, edit.offset);\n        end = Math.max(end, edit.offset + edit.length);\n        end += edit.content.length - edit.length;\n    }\n    // create a single edit with all changes\n    const editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport const createScanner = scanner.createScanner;\nexport var ScanError;\n(function (ScanError) {\n    ScanError[ScanError[\"None\"] = 0] = \"None\";\n    ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n    ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n    ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n    ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n    ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError || (ScanError = {}));\nexport var SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n    SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n    SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n    SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n    SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n    SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n    SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n    SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n    SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n    SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n    SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n    SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n    SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n    SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n    SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n})(SyntaxKind || (SyntaxKind = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport const getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport const parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport const parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport const findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport const findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport const getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport const getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport const visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport const stripComments = parser.stripComments;\nexport var ParseErrorCode;\n(function (ParseErrorCode) {\n    ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n    ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n    ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n    ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n    ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n    ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n    ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n    ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n    ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n})(ParseErrorCode || (ParseErrorCode = {}));\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* ParseErrorCode.InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* ParseErrorCode.InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* ParseErrorCode.PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ParseErrorCode.ValueExpected */: return 'ValueExpected';\n        case 5 /* ParseErrorCode.ColonExpected */: return 'ColonExpected';\n        case 6 /* ParseErrorCode.CommaExpected */: return 'CommaExpected';\n        case 7 /* ParseErrorCode.CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* ParseErrorCode.CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* ParseErrorCode.EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* ParseErrorCode.InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* ParseErrorCode.UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* ParseErrorCode.UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* ParseErrorCode.UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* ParseErrorCode.InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* ParseErrorCode.InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* ParseErrorCode.InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edit operations needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edit operations needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to an input string.\n * @param text The input text\n * @param edits Edit operations following the format described in {@linkcode EditResult}.\n * @returns The text with the applied edits.\n * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.\n */\nexport function applyEdits(text, edits) {\n    let sortedEdits = edits.slice(0).sort((a, b) => {\n        const diff = a.offset - b.offset;\n        if (diff === 0) {\n            return a.length - b.length;\n        }\n        return diff;\n    });\n    let lastModifiedOffset = text.length;\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\n        let e = sortedEdits[i];\n        if (e.offset + e.length <= lastModifiedOffset) {\n            text = edit.applyEdit(text, e);\n        }\n        else {\n            throw new Error('Overlapping edit');\n        }\n        lastModifiedOffset = e.offset;\n    }\n    return text;\n}\n"],
  "mappings": "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E,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,IAAI,IAAI,EAAE,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,IAAI,IAAI,EAAE,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,IAAI,IAAI,EAAE,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,IAAI,IAAI,EAAE,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,GAAG,IAAI;AAC5C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EAAAA,gBAAeA,gBAAe,GAAG,IAAI,EAAE,IAAI;AAC3C,EA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",
  "names": ["value", "CharacterCodes", "ParseOptions", "edit", "createScanner", "ScanError", "SyntaxKind", "getLocation", "parse", "parseTree", "findNodeAtLocation", "findNodeAtOffset", "getNodePath", "getNodeValue", "visit", "stripComments", "ParseErrorCode", "format"]
}
